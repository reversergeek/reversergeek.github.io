= Reversing and Decrypting the Challenger Encrypted File Format

To demonstrate that I can decrypt encrypted, proprietary file formats I have 


The software I've picked is named "Challenger". The challenge is to imagine that Challenger's trial licence has expired and you can no-longer use the software. The passwords/keys are known, however (we're not breaking AES here :p).


== Analysing the Files


I encrypted my copy of PEiD.exe and it produced PEiD.exe.cha. I also encrypted a  readme.txt file which produced readme.cha. Both encrypted .cha files are 71 bytes larger than their origionals. This suggests a 71 byte header. Let's look at them in a hex dump and compare them.

image::http://i.imgur.com/Bo5zJYS.png[]

You can see the green bytes are the same and the yellow bytes are different. You can also see that the last 3 bytes of the 71 bytes header denotes the file plaintext file's file extention.

Let's see what happens if we encrypt the same file with two different keys.

image::http://i.imgur.com/4MtvTxH.png[]

This time different information changes and different information stays the same between the two compared files.

Thirdly we'll see if there's any difference in the .cha files produced by encrypting the same file twice with the same key.

image::http://i.imgur.com/zYlWDaK.png[]

So some bytes always stay the same. Some bytes always change. Some bytes only change with different keys. And some bytes change with different files.

In summary, according to analysis of the few files I've made in this one virtual machine:

* The first 24 bytes are allways the same.
* The following 4 bytes are different in every file.
* The following 8 bytes are the same in every file.
* The following 8 bytes are the different if there are different keys.
* The following 12 bytes are different in every file.
* The following 2 bytes are different if the file or key is different.
* The following 3 bytes are the same in every file.
* The following 4 bytes are the diffrent if there are different keys.
* The following 3 bytes are the same in every file.
* The following x bytes are clearly a copy of the plaintext's file extention and will be as long as that file extention is (I checked by encrypting a file with a 6 letter extention).
* The following bytes are all variable and must be the ciphertext.

That's everything we can tell from the files. Let's do some debugging...

== Reverse Engineering the Binary

First checks with PEiD show no signature for a compiler or packer (so it could be packed), it also fails to find any crypto signatures other than CRC32


When we first run the program it asks us to enter a password start password. The crypto key will be generated from this password.

image::http://i.imgur.com/cJgPvZE.png[]

Next we can see a button labelled "Encrypt/Decrypt file...". When we click it we get a open file dialogue. I wonder if that's a secure erase or just a deletion, but let's not go off on to a tangent.

image::http://i.imgur.com/b6N1JC5.png[]

After selecting the file there's a dialogue with a button 'Encrypt'. When we click that button Challenger creates and encrypted copy of our file and deletes the old one.

image::http://i.imgur.com/7OZhY5I.png[]

If we go though the same dialogues again, but this time select the encrypted file, Challenger will give us an active' 'decrypt' button. 

image::http://i.imgur.com/3LqFPpu.png[]

It's likely that the very next thing that Challenger will do is to open the file, read it, and decrypt it. By putting breakpoints on all intermodular calls to CreateFile and ReadFile and clicking that button it's likley that one of the first breakpoints .

image::http://i.imgur.com/vLdAsqA.png[]

Bamm! We hit the exact call that we wanted. Looks like this is in a very important routine, too.

There are two ReadFile's after CreateFileW opens the file. The first only reads a hardcoded 68 bytes (the header), the second reads 3 bytes - the file extention.

<img7+7>

TODO: use hardware breakpoints on the cipher text to find all reads from it. Look at the refrence graphs from IDA to see how deep the functions calls go, then step though them giving IDA the variable names. 

-You could have had the idea to ask reddit about the crypto function using the problem solving technique.

The next ReadFile 

The next CreateFileW creates the new plaintext file (based on the file path+name with the .cha file extension (or .ch2) removed and the original extension ('exe' in this case) on the end (if it wouldn't be already).

<img8>

The third Readfile 


